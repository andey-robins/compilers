/*
 * program3.ypp
 * Andey Robins
 * 10/5/22
 * Compilers Program 3
 *
 * The bison input file for program3
 */
%{

#include <iostream>
#include <FlexLexer.h>
#include <string>
#include <typeinfo>
#include "nodes/include/nodes.hpp"
#define YYERROR_VERBOSE

using std::cerr;
using std::cout;
using std::endl;

class Node;
extern Node *tree;
extern yyFlexLexer lexer;

#define yylex() lexer.yylex()
void yyerror(const char* string);

%}

%locations

%union {
    Node *ttype;
}

%precedence "shift"
%precedence "reduce"

%type<ttype> program elements vardec exp type multibrackets name newexp simpletype optprogram bracketexp bracketexps optbracketexps

%token<ttype> SEMI DOT
%token<ttype> ID
%token<ttype> NUMBER NULLT READ NEW THIS
%left<ttype> LPAREN RPAREN LBRACKET RBRACKET
%left<ttype> PLUS MINUS NOT OR
%left<ttype> TIMES DIV MOD AND
%left<ttype> EQ NE GE LE GT LT
%token<ttype> INT

// TODO: Remove these
%token ER_WD ER_CH TAB WHILE RETURN CLASS PRINT VOID ELSE IF COMMA ASSIGN KEY_INT RBRACE LBRACE  

%expect 0

%%

program:
    elements optprogram { 
        tree=new NodeProgram(static_cast<NodeElement*>($1));
        tree->setNext($2);
        cout << $1->getType() << endl;
        $$=tree;
    }
;

optprogram:
    elements optprogram {
        $1->setNext($2);
        cout << $1->getType() << endl;
        $$ = new NodeOptProgram(static_cast<NodeElement*>($1));
    }
|   /* epsilon */ {
        $$ = new NodeEpsilon();
    }
;

elements:
    vardec { $$=$1; }
|   exp SEMI { 
        $1->setType("elements");
        $$=$1; 
    }
;

// TODO: Vardecs
vardec:
    type ID SEMI { $$ = $1; }
|   ID ID SEMI { $$ = $1; }
|   type multibrackets ID SEMI { $$ = $1; }
|   ID multibrackets ID SEMI { $$ = $1; }
;

exp:
    name { $$ = new NodeExp(static_cast<NodeName*>($1)); }
|   NUMBER { $$ = new LeafNumber($1->getInt()); }
|   NULLT { $$=new LeafKeyword("null"); }
|   READ LPAREN RPAREN { $$=new LeafKeyword("read"); }
|   newexp { 
        $$ = $1; 
    }
|   LPAREN exp RPAREN
|   name LPAREN RPAREN { $$ = new NodeCallExp(static_cast<NodeName*>($1)); }
|   exp PLUS exp
|   exp MINUS exp
|   exp OR exp
|   exp TIMES exp
|   exp DIV exp
|   exp MOD exp
|   exp AND exp
|   exp EQ exp
|   exp NE exp
|   exp GE exp
|   exp LE exp
|   exp GT exp
|   exp LT exp
|   MINUS exp
|   PLUS exp
|   NOT exp
;

// TODO: finish these
newexp:
    NEW ID LPAREN RPAREN { 
        $$=new NodeNewExp($2->getString()); 
    }
|   NEW simpletype {
        $$ = new NodeNewExpType(static_cast<NodeType*>($2));
    }
|   NEW simpletype bracketexps {
        $$ = new NodeNewExpTypeBrack(static_cast<NodeType*>($2), static_cast<NodeBracketExp *>($3));
    }
|   NEW ID bracketexps {}
|   NEW simpletype bracketexps multibrackets {}
|   NEW ID bracketexps multibrackets {}
;

type:
    simpletype { $$=new NodeType(static_cast<NodeSimpleType*>($1)); }
;

simpletype:
    INT { 
        $$=new NodeSimpleType("int"); 
    }
;

bracketexps:
    bracketexp optbracketexps { 
        $1->setNext($2);
        $$ = new NodeBracketExp(static_cast<NodeExp*>($1)); 
    }
;

optbracketexps:
    bracketexp optbracketexps { 
        $1->setNext($2);
        $$ = new NodeBracketExp(static_cast<NodeExp*>($1));
    }
|   /* epsilon */  %prec "shift" { $$ = new NodeEpsilon(); }
;

bracketexp:
    LBRACKET exp RBRACKET { 
        $$ = new NodeExp($2); 
    }
|   LBRACKET RBRACKET { $$ = new NodeEpsilon(); }
;

multibrackets:
    LBRACKET RBRACKET
|   multibrackets LBRACKET RBRACKET
;

name:
    THIS { $$=new LeafKeyword("this"); }
|   ID %prec "shift" { $$=new LeafId($1->getString()); }
|   name DOT ID 
|   name bracketexps
;

%%
