/*
 * program4.ypp
 * Andey Robins
 * 10/20/22
 * Compilers Program 4
 *
 * The bison input file for program4
 */
%{

#include <iostream>
#include <FlexLexer.h>
#include <string>
#include <typeinfo>
#include "nodes/include/nodes.hpp"
#define YYERROR_VERBOSE

using std::cerr;
using std::cout;
using std::endl;

class BaseNode;
extern BaseNode *ast;
extern yyFlexLexer lexer;

#define yylex() lexer.yylex()
void yyerror(const char* string);

%}

%locations

%union {
    BaseNode *ttype;
}

%precedence "shift"
%precedence "reduce"

%type<ttype> program classDeclarations classBody varDeclHeaderChoice constDeclHeaderChoice methDeclHeaderChoice type parameterList parameterListStar parameter localVarDeclaration statement name argList conditionalStatement expression newExpression bracks rterm term factor block blockHeadChoice blockStatementChoice

%left<ttype> PLUS MINUS NOT OR
%token<ttype> SEMI DOT COMMA
%token<ttype> ID
%left<ttype> LPAREN RPAREN LBRACKET RBRACKET RBRACE LBRACE
%token<ttype> NUMBER NULLT READ NEW THIS
%left<ttype> IF ELSE WHILE RETURN CLASS PRINT VOID
%left<ttype> TIMES DIV MOD AND
%left<ttype> EQ NE GE LE GT LT ASSIGN
%token<ttype> INT

// To be made use of in the future
%token<ttype> ER_WD ER_CH

%expect 0

%%

program:
    classDeclarations { 
        ast = new NProgram(static_cast<NClassDecl *>($1));
        $$ = ast;
    }
;

classDeclarations:
    CLASS ID classBody {
        NId *id = new NId($2->getText());
        $$ = new NClassDecl(id, static_cast<NClassBody *>($3));
    }
;

classBody:
    LBRACE varDeclHeaderChoice {
        // TODO check if we only got back an epsilon for an empty body
        auto *derivedVar = dynamic_cast<NVarDecl *>($2);
        auto *derivedConst = dynamic_cast<NConstDecl *>($2);
        auto *derivedMeth = dynamic_cast<NMethDecl *>($2);

        if (derivedVar) 
        {
            $$ = new NClassBody(derivedVar);
        }
        else if (derivedConst) 
        {
            $$ = new NClassBody(derivedConst);
        }
        else if (derivedMeth) 
        {
            $$ = new NClassBody(derivedMeth);
        }
        else
        {
            // TODO remove
            cout << "Oh noes" << endl;
        }
    }
;

varDeclHeaderChoice:
    INT bracks ID SEMI varDeclHeaderChoice {
        int bracks = static_cast<NType*>($2)->getBracks();
        NKeyword *key = new NKeyword($1->getText());
        NSimpleType *st = new NSimpleType(key);
        NType *stWrapper = new NType(st);
        NType *type = new NType(stWrapper, bracks);
        NVarDecl *curr = new NVarDecl(type, static_cast<NId*>($3));
        curr->setNext($5);
        $$ = curr;
    }
|   ID bracks ID SEMI varDeclHeaderChoice {
        int bracks = static_cast<NType*>($2)->getBracks();
        NId *id = new NId($1->getText());
        NSimpleType *st = new NSimpleType(id);
        NType *stWrapper = new NType(st);
        NType *type = new NType(stWrapper, bracks);
        NVarDecl *curr = new NVarDecl(type, static_cast<NId*>($3));
        curr->setNext($5);
        $$ = curr;
    }
|   INT ID SEMI varDeclHeaderChoice {
        NKeyword *key = new NKeyword($1->getText());
        NId *id = new NId($2->getText());
        NSimpleType *st = new NSimpleType(key);
        NType *type = new NType(st);
        NVarDecl *curr = new NVarDecl(type, id);
        curr->setNext($4);
        $$ = curr;
    }
|   ID ID SEMI varDeclHeaderChoice {
        NId *idOne = new NId($1->getText());
        NId *idTwo = new NId($2->getText());
        NSimpleType *st = new NSimpleType(idOne);
        NType *type = new NType(st);
        NVarDecl *curr = new NVarDecl(type, idTwo);
        curr->setNext($4);
        $$ = curr;
    }
    
|   constDeclHeaderChoice { 
        cout << "done with vardecls" << endl;
        $$ = $1; 
    }
;

constDeclHeaderChoice:
    ID LPAREN parameterList RPAREN block constDeclHeaderChoice {
        cout << "to constDeclHeaderChoice" << endl;
        NId *id = new NId($1->getText());
        NConstDecl *curr;
        if ($3->getText() == "epsilon") 
        {
            NParam *epsilon = new NParam(0, 0);
            epsilon->setVal("epsilon");
            curr = new NConstDecl(id, epsilon, static_cast<NBlock *>($5));
        }
        else 
        {
            curr = new NConstDecl(id, static_cast<NParam *>($3), static_cast<NBlock *>($5));
        }
        curr->setNext($6);
        $$ = curr;
    }
|   methDeclHeaderChoice { 
        // TODO remove
        $$ = $1; 
    }
;

methDeclHeaderChoice:
    VOID ID LPAREN parameterList RPAREN block constDeclHeaderChoice {
        cout << "at meth decl 1" << endl;
        NId *id = new NId($2->getText());
        NKeyword *key = new NKeyword("void");
        NSimpleType *st = new NSimpleType(key);
        NType *type = new NType(st);
        NResultType *resType = new NResultType(type);
        NMethDecl *method = new NMethDecl(resType, id, static_cast<NParam *>($4), static_cast<NBlock *>($6));
        method->setNext($7);
        $$ = method;
    }
|   INT bracks ID LPAREN parameterList RPAREN block constDeclHeaderChoice {
        cout << "at meth decl 2" << endl;
        int bracks = static_cast<NType*>($2)->getBracks();
        NId *id = new NId($3->getText());
        NKeyword *intId = new NKeyword("int");
        NSimpleType *st = new NSimpleType(intId);
        NType *stWrapper = new NType(st);
        NType *type = new NType(stWrapper, bracks);
        NResultType *resType = new NResultType(type);
        NMethDecl *method = new NMethDecl(resType, id, static_cast<NParam *>($5), static_cast<NBlock *>($7));
        method->setNext($8);
        $$ = method;
    }
|   ID bracks ID LPAREN parameterList RPAREN block constDeclHeaderChoice {
        cout << "at meth decl 3" << endl;
        int bracks = static_cast<NType*>($2)->getBracks();
        NId *id = new NId($3->getText());
        NId *intId = new NId($1->getText());
        NSimpleType *st = new NSimpleType(intId);
        NType *stWrapper = new NType(st);
        NType *type = new NType(stWrapper, bracks);
        NResultType *resType = new NResultType(type);
        NMethDecl *method = new NMethDecl(resType, id, static_cast<NParam *>($5), static_cast<NBlock *>($7));
        method->setNext($8);
        $$ = method;
    }
|   INT ID LPAREN parameterList RPAREN block constDeclHeaderChoice {
        cout << "at meth decl 4" << endl;
        NId *id = new NId($2->getText());
        NKeyword *key = new NKeyword("int");
        NSimpleType *st = new NSimpleType(key);
        NType *type = new NType(st);
        NResultType *resType = new NResultType(type);
        NMethDecl *method = new NMethDecl(resType, id, static_cast<NParam *>($4), static_cast<NBlock *>($6));
        method->setNext($7);
        $$ = method;
    }
|   ID ID LPAREN parameterList RPAREN block constDeclHeaderChoice {
        cout << "at meth decl 5" << endl;
        NId *id = new NId($2->getText());
        NKeyword *key = new NKeyword("int");
        NSimpleType *st = new NSimpleType(key);
        NType *type = new NType(st);
        NResultType *resType = new NResultType(type);
        NMethDecl *method = new NMethDecl(resType, id, static_cast<NParam *>($4), static_cast<NBlock *>($6));
        method->setNext($7);
        $$ = method;
    }
|   RBRACE {
        cout << "at rbrace" << endl;
        $$ = new NEpsilon();
    }
;

type:
    INT bracks {
        int bracks = static_cast<NType*>($2)->getBracks();
        NKeyword *key = new NKeyword("int");
        NSimpleType *st = new NSimpleType(key);
        NType *stWrapper = new NType(st);
        NType *type = new NType(stWrapper, bracks);
        $$ = type;
    }
|   ID bracks {
        int bracks = static_cast<NType*>($2)->getBracks();
        NId *id = new NId($1->getText());
        NSimpleType *st = new NSimpleType(id);
        NType *stWrapper = new NType(st);
        NType *type = new NType(stWrapper, bracks);
        $$ = type;
    }
;

parameterList:
    parameter parameterListStar {
        cout << "at parameterlist" << endl;
        if ($2->getText() != "epsilon")
        {
            $1->setNext($2);
        }
        $$ = static_cast<NParam *>($1);
    }
|   /* epsilon */ {
        $$ = new NEpsilon();
    }
;

parameterListStar:
    COMMA parameter parameterListStar {
        cout << "to param list star" << endl;
        if ($3->getText() != "epsilon")
        {
            $2->setNext($3);

        }
        $$ = static_cast<NParam *>($2);
    }
|   /* epsilon */ {
        cout << "to param list star epsilon" << endl;
        $$ = new NEpsilon();
    }

parameter:
    type ID {
        cout << "to param" << endl;
        NId *id = new NId($2->getText());
        NParam *param = new NParam(static_cast<NType *>($1), id);
        $<ttype>$ = param;
    }
|   INT ID {
        cout << "to param 2" << endl;
        NKeyword *key = new NKeyword("int");
        NSimpleType *st = new NSimpleType(key);
        NType *type = new NType(st);
        NId *id = new NId($2->getText());
        NParam *param = new NParam(type, id);
        $$ = param;
    }
|   ID ID {
        cout << "to param 3" << endl;
        NId *idOne = new NId($1->getText());
        NId *idTwo = new NId($2->getText());
        NSimpleType *st = new NSimpleType(idOne);
        NType *type = new NType(st);
        NParam *param = new NParam(type, idTwo);
        $$ = param;
    }
;

block:
    LBRACE blockHeadChoice {
        auto *derivedLocalVars = dynamic_cast<NLocalVarDecl *>($2);
        auto *derivedStatements = dynamic_cast<NStatement *>($2);
        auto *derivedEpsilon = dynamic_cast<NEpsilon *>($2);

        if (derivedLocalVars)
        {
            $$ = new NBlock(derivedLocalVars);
        }
        else if (derivedStatements)
        {
            $$ = new NBlock(derivedStatements);
        }
        else if (derivedEpsilon)
        {
            $$ = derivedEpsilon;
        }
        else
        {
            // TODO remove
            cout << "Oh noes 2" << endl;
        }
    }
;

blockHeadChoice:
    localVarDeclaration blockStatementChoice {
        if ($2->getText() != "epsilon")
        {
            $1->setNext($2);
        }

        $<ttype>$ = $1;
    }
|   blockStatementChoice {
        // TODO remove
        $$ = $1;
    }
;

blockStatementChoice:
    statement blockHeadChoice {
        if ($2->getText() != "epsilon")
        {
            $1->setNext($2);
        }
        $$ = $1;
    }
|   RBRACE {
        $$ = new NEpsilon();
    }
;

localVarDeclaration:
    type ID SEMI {
        NId *id = new NId($2->getText());
        $$ = new NVarDecl(static_cast<NType *>($1), id);
    }
|   INT ID SEMI {
        NId *id = new NId($2->getText());
        NKeyword *key = new NKeyword("int");
        NSimpleType *st = new NSimpleType(key);
        NType *type = new NType(st);
        NVarDecl *var = new NVarDecl(type, id);
        $$ = new NLocalVarDecl(var);
    }
|   ID ID SEMI {
        NId *idOne = new NId($1->getText());
        NId *idTwo = new NId($2->getText());
        NSimpleType *st = new NSimpleType(idOne);
        NType *type = new NType(st);
        NVarDecl *var = new NVarDecl(type, idTwo);
        $$ = new NLocalVarDecl(var);
    }
;

statement:
    SEMI {
        $$ = new NEpsilon();
    }
|   thisName ASSIGN expression SEMI {
        // TODO
    }
|   thisName LPAREN argList RPAREN SEMI {
        // TODO
    }
|   PRINT LPAREN argList RPAREN SEMI {
        // TODO
    }
|   conditionalStatement {
        // TODO
    }
|   WHILE LPAREN expression RPAREN statement {
        // TODO
    }
|   RETURN expression SEMI {
        // TODO
    }
|   RETURN SEMI {
        // TODO
    }
|   block {
        // TODO
    }
;

thisName:
    THIS name {

    }
|   name
;

name:
    ID {
        // TODO
    }
|   ID DOT name {
        // TODO
    }
|   ID brackExp {
        // TODO
    }
;

argList:
    expression argList {
        // TODO
    }
|   /* epsilon */ {
        // $$ = new NEpsilon();
    }
;

conditionalStatement:
    IF LPAREN expression RPAREN statement {
        // TODO
    }
|   IF LPAREN expression RPAREN statement ELSE statement {
        // TODO
    }
;

expression:
    expression EQ expression { }
|   expression NE expression { }
|   expression LT expression { }
|   expression GT expression { }
|   expression LE expression { }
|   expression GE expression { }
|   expression PLUS term
|   expression MINUS term
|   expression OR rterm
|   term

;

rterm:
    term TIMES term
|   term DIV term
|   term MOD term
|   term AND term
;

term:
    rterm
|   factor
;

factor:
    // currently no unary ops, but otherwise all correct
    NOT factor
|   thisName %prec "shift" {
        // TODO
    }
|   LPAREN expression RPAREN {
        // TODO
    }
|   NUMBER {
        // TODO
    }
|   NULLT {
        // TODO
    }
|   thisName LPAREN argList RPAREN {
        // TODO
    }
|   READ LPAREN RPAREN {
        // TODO
    }
|   newExpression {
        // TODO
    }
;

newExpression:
    NEW ID LPAREN argList RPAREN {
        // TODO
    }
|   NEW newExpTypes {
        // TODO
    }
|   NEW newExpTypes bracks {
        // TODO
    }
|   NEW newExpTypes brackExp {
        // TODO
    }
|   NEW newExpTypes brackExp bracks {
        // TODO
    }
;

newExpTypes:
    ID %prec "reduce" {
        // TODO
    }
|   INT {
        // TODO
    }
;

brackExp:
    LBRACKET expression RBRACKET brackExp {

    }
|   LBRACKET expression RBRACKET {

    }
;

bracks:
    LBRACKET RBRACKET bracks {
        $$ = new NType(0, static_cast<NType*>($3)->getBracks()+1);
    }
|   LBRACKET RBRACKET {
        $$ = new NType(0, 1);
    }
;


%%
