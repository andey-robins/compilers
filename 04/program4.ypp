/*
 * program4.ypp
 * Andey Robins
 * 10/20/22
 * Compilers Program 4
 *
 * The bison input file for program4
 */
%{

#include <iostream>
#include <FlexLexer.h>
#include <string>
#include <typeinfo>
#include "nodes/include/nodes.hpp"
#define YYERROR_VERBOSE

using std::cerr;
using std::cout;
using std::endl;

class BaseNode;
extern BaseNode *ast;
extern yyFlexLexer lexer;

#define yylex() lexer.yylex()
void yyerror(const char* string);

%}

%locations

%union {
    BaseNode *ttype;
}

%precedence "shift"
%precedence "reduce"

%type<ttype> program classDeclarations classBody varDeclHeaderChoice constDeclHeaderChoice methDeclHeaderChoice type parameterList parameterListStar parameter localVarDeclaration statement name argList conditionalStatement expression newExpression bracks rterm term factor

%left<ttype> PLUS MINUS NOT OR
%token<ttype> SEMI DOT COMMA
%token<ttype> ID
%left<ttype> LPAREN RPAREN LBRACKET RBRACKET RBRACE LBRACE
%token<ttype> NUMBER NULLT READ NEW THIS
%left<ttype> IF ELSE WHILE RETURN CLASS PRINT VOID
%left<ttype> TIMES DIV MOD AND
%left<ttype> EQ NE GE LE GT LT ASSIGN
%token<ttype> INT

// To be made use of in the future
%token<ttype> ER_WD ER_CH

%expect 0

%%

program:
    classDeclarations { 
        tree = new NProgram(static_cast<NClassDecl*>($1));
        $$ = tree;
    }
;

classDeclarations:
    CLASS ID classBody {
        NKeyword *cls = new NKeyword($1);
        $$ = new NClassDecl(cls, $2, $3);
    }
;

classBody:
    LBRACE varDeclHeaderChoice {
        
    }
;

varDeclHeaderChoice:
    INT bracks ID SEMI varDeclHeaderChoice {

    }
|   ID bracks ID SEMI varDeclHeaderChoice {

    }
|   constDeclHeaderChoice
;

constDeclHeaderChoice:
    ID LPAREN parameterList RPAREN block constDeclHeaderChoice {

    }
|   VOID ID LPAREN parameterList RPAREN block constDeclHeaderChoice {

    }
|   methDeclHeaderChoice
;

methDeclHeaderChoice:
    INT bracks ID LPAREN parameterList RPAREN block constDeclHeaderChoice {

    }
|   ID bracks ID LPAREN parameterList RPAREN block constDeclHeaderChoice {

    }
|   RBRACE { }
;

type:
    INT bracks {
        // TODO
    }
|   ID bracks {
        // TODO
    }
;

parameterList:
    parameter parameterListStar {
        // TODO properly build this list
        $$ = new LParams();
    }
|   /* epsilon */ {
        $$ = new NEpsilon();
    }
;

parameterListStar:
    COMMA parameter parameterListStar {

    }
|   /* epsilon */ {
        $$ = new NEpsilon();
    }

parameter:
    type ID {
        $$ = new NParam(static_cast<NType *>($1), static_cast<NId *>($2));
    }
;

block:
    LBRACE blockHeadChoice {
        // TODO
    }
;

blockHeadChoice:
    // TODO, split to avoid vardecls after statement decls
    localVarDeclaration blockHeadChoice {

    }
|   statement blockHeadChoice {
        // done w/ local var decls
    }
|   RBRACE {}

localVarDeclaration:
    type ID SEMI {
        $$ = new NVarDecl(static_cast<NType *>($1), static_cast<NId *>($2));
    }
;

statement:
    SEMI {}
|   thisName ASSIGN expression SEMI {
        // TODO
    }
|   thisName LPAREN argList RPAREN SEMI {
        // TODO
    }
|   PRINT LPAREN argList RPAREN SEMI {
        // TODO
    }
|   conditionalStatement {
        // TODO
    }
|   WHILE LPAREN expression RPAREN statement {
        // TODO
    }
|   RETURN expression SEMI {
        // TODO
    }
|   RETURN SEMI {
        // TODO
    }
|   block {
        // TODO
    }
;

thisName:
    THIS name {

    }
|   name

name:
    ID {
        // TODO
    }
|   ID DOT name {
        // TODO
    }
|   ID brackExp {
        // TODO
    }
;

argList:
    expression argList {
        // TODO
    }
|   /* epsilon */ {
        $$ = new NEpsilon();
    }
;

conditionalStatement:
    IF LPAREN expression RPAREN statement {
        // TODO
    }
|   IF LPAREN expression RPAREN statement ELSE statement {
        // TODO
    }
;

expression:
    expression EQ expression { }
|   expression NE expression { }
|   expression LT expression { }
|   expression GT expression { }
|   expression LE expression { }
|   expression GE expression { }
|   expression PLUS term
|   expression MINUS term
|   expression OR rterm
|   term

;

rterm:
    term TIMES term
|   term DIV term
|   term MOD term
|   term AND term
;

term:
    rterm
|   factor
;

factor:
    // currently no unary ops, but otherwise all correct
    NOT factor
|   thisName %prec "shift" {
        // TODO
    }
|   LPAREN expression RPAREN {
        // TODO
    }
|   NUMBER {
        // TODO
    }
|   NULLT {
        // TODO
    }
|   thisName LPAREN argList RPAREN {
        // TODO
    }
|   READ LPAREN RPAREN {
        // TODO
    }
|   newExpression {
        // TODO
    }
;

newExpression:
    NEW ID LPAREN argList RPAREN {
        // TODO
    }
|   NEW newExpTypes {
        // TODO
    }
|   NEW newExpTypes bracks {
        // TODO
    }
|   NEW newExpTypes brackExp {
        // TODO
    }
|   NEW newExpTypes brackExp bracks {
        // TODO
    }
;

newExpTypes:
    ID %prec "reduce" {
        // TODO
    }
|   INT {
        // TODO
    }
;

brackExp:
    LBRACKET expression RBRACKET brackExp {

    }
|   LBRACKET expression RBRACKET {

    }
;

bracks:
    LBRACKET RBRACKET bracks {
        // TODO
    }
|   LBRACKET RBRACKET
;


%%
