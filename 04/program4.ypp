/*
 * program4.ypp
 * Andey Robins
 * 10/20/22
 * Compilers Program 4
 *
 * The bison input file for program4
 */
%{

#include <iostream>
#include <FlexLexer.h>
#include <string>
#include <typeinfo>
#include "nodes/include/nodes.hpp"
#define YYERROR_VERBOSE

using std::cerr;
using std::cout;
using std::endl;

class BaseNode;
extern BaseNode *ast;
extern yyFlexLexer lexer;

#define yylex() lexer.yylex()
void yyerror(const char* string);

%}

%locations

%union {
    BaseNode *ttype;
}

%precedence "shift"
%precedence "reduce"

%type<ttype> program classDeclarations classBody varDeclarationList type simpleType constructorDeclarationList methodDeclarationList resultType parameterList parameterListStar parameter localVarDeclarationStar localVarDeclaration statementStar statement name argList conditionalStatement maybeElse optionalExpression expression newExpression brackExp bracks

%token<ttype> SEMI DOT
%token<ttype> ID
%token<ttype> NUMBER NULLT READ NEW THIS
%left<ttype> LPAREN RPAREN LBRACKET RBRACKET
%left<ttype> PLUS MINUS NOT OR
%left<ttype> TIMES DIV MOD AND
%left<ttype> EQ NE GE LE GT LT
%token<ttype> INT

// To be made use of in the future
%token<ttype> ER_WD ER_CH TAB WHILE RETURN CLASS PRINT VOID ELSE IF COMMA ASSIGN RBRACE LBRACE

%expect 0

%%

program:
    classDeclarations { 
        tree = new NProgram(static_cast<NClassDecl*>($1));
        $$ = tree;
    }
;

classDeclarations:
    CLASS ID classBody {
        NKeyword *cls = new NKeyword($1);
        $$ = new NClassDecl(cls, $2, $3);
    }
;

classBody:
    LBRACE varDeclarationList constructorDeclarationList methodDeclarationList RBRACE {
        $$ = new NClassBody($1, $2, $3);
    }
;

varDeclarationList:
    type ID SEMI varDeclarationList {
        // TODO
    }
|   /* epsilon */ {
        $$ = new NEpsilon();
    }
;

type:
    simpleType bracks %prec "reduce" {
        $$ = new NType($1)
    }
;

simpleType:
    INT {
        NKeyword *intKword = new NKeyword("int");
        $$ = new NSimpleType(static_cast<NKeyword *>(intKword));
    }
|   ID {
        $$ = new NSimpleType($1);
    }
;

constructorDeclarationList:
    ID LPAREN parameterList RPAREN block {
        // TODO
    }
|   /* epsilon */ {
        $$ = new NEpsilon();
    }
;

methodDeclarationList:
    resultType ID LPAREN parameterList RPAREN block {
        // TODO
    }
|   /* epsilon */ {
        $$ = new NEpsilon();
    }
;

resultType:
    type {
        $$ = new NResultType(static_cast<NType *>($1));
    }
|   VOID {
        $$ = new NKeyword("void");
    }
;

parameterList:
    parameter parameterListStar {
        // TODO properly build this list
        $$ = new LParams();
    }
|   /* epsilon */ {
        $$ = new NEpsilon();
    }
;

parameterListStar:
    COMMA parameter parameterListStar {

    }
|   /* epsilon */ {
        $$ = new NEpsilon();
    }

parameter:
    type ID {
        $$ = new NParam(static_cast<NType *>($1), static_cast<NId *>($2));
    }
;

block:
    LBRACE localVarDeclarationStar statementStar RBRACE {
        // TODO
    }
;

localVarDeclarationStar:
    localVarDeclaration localVarDeclarationStar {

    }
|   /* epsilon */ {
        $$ = new NEpsilon();
    }
;

localVarDeclaration:
    type ID SEMI {
        $$ = new NVarDecl(static_cast<NType *>($1), static_cast<NId *>($2));
    }
;

statementStar:
    statement statementStar {
        // TODO
    }
|   /* epsilon */ {
        $$ = new NEpsilon();
    }
;

statement:
    SEMI {}
|   name ASSIGN expression SEMI {
        // TODO
    }
|   name LPAREN argList RPAREN SEMI {
        // TODO
    }
|   PRINT LPAREN argList RPAREN SEMI {
        // TODO
    }
|   conditionalStatement {
        // TODO
    }
|   WHILE LPAREN expression RPAREN statement {
        // TODO
    }
|   RETURN optionalExpression {
        // TODO
    }
|   block {
        // TODO
    }
;

name:
    THIS {
        // TODO
    }
|   ID {
        // TODO
    }
|   name DOT ID {
        // TODO
    }
|   name LBRACKET expression RBRACKET {
        // TODO
    }
;

argList:
    expression argList {
        // TODO
    }
|   /* epsilon */ {
        $$ = new NEpsilon();
    }
;

conditionalStatement:
    IF LPAREN expression RPAREN statement maybeElse {
        // TODO
    }
;

maybeElse:
    ELSE statement {
        // TODO
    }
|   /* epsilon */ {
        $$ = new NEpsilon();
    }
;

optionalExpression:
    expression {
        // TODO
    }
|   /* epsilon */ {
        $$ = new NEpsilon();
    }
;

expression:
    name {
        // TODO
    }
|   LPAREN expression RPAREN {
        // TODO
    }
|   NUMBER {
        // TODO
    }
|   NULLT {
        // TODO
    }
|   name LPAREN argList RPAREN {
        // TODO
    }
|   READ LPAREN RPAREN {
        // TODO
    }
|   newExpression {
        // TODO
    }

|   expression PLUS expression { }
|   expression MINUS expression { }
|   expression OR expression { }
|   expression AND expression %prec "reduce" { }
|   expression TIMES expression %prec "reduce" { }
|   expression DIV expression %prec "reduce" { }
|   expression MOD expression %prec "reduce" { }
|   expression EQ expression { }
|   expression NE expression { }
|   expression LT expression { }
|   expression GT expression { }
|   expression LE expression { }
|   expression GE expression { }
|   PLUS expression {
        // TODO
    }
|   MINUS expression {
        // TODO
    }
|   NOT expression {
        // TODO
    }
;

newExpression:
    NEW ID LPAREN argList RPAREN {
        // TODO
    }
|   NEW simpleType brackExp bracks {
        // TODO
    }
;

brackExp:
    LBRACKET expression RBRACKET brackExp {
        // TODO
    }
|   /* epsilon */ {
        $$ = new NEpsilon();
    }
;

bracks:
    LBRACKET RBRACKET bracks {
        // TODO
    }
|   /* epsilon */ {
        $$ = new NEpsilon();
    }
;


%%
