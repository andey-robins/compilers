/*
 * program4.ypp
 * Andey Robins
 * 10/20/22
 * Compilers Program 4
 *
 * The bison input file for program4
 */
%{

#include <iostream>
#include <FlexLexer.h>
#include <string>
#include <typeinfo>
#include "nodes/include/nodes.hpp"
#define YYERROR_VERBOSE

using std::cerr;
using std::cout;
using std::endl;

class BaseNode;
extern BaseNode *ast;
extern yyFlexLexer lexer;

#define yylex() lexer.yylex()
void yyerror(const char* string);

%}

%locations

%union {
    BaseNode *ttype;
}

%precedence "shift"
%precedence "reduce"

%type<ttype> program classDeclarations classBody varDeclarationList type simpleType constructorDeclarationList methodDeclarationList resultType parameterList parameterListStar parameter localVarDeclarationStar localVarDeclaration statementStar statement name argList argListStar conditionalStatement maybeElse optionalExpression expression newExpression unaryOp relationOp sumOp productOp

%token<ttype> SEMI DOT
%token<ttype> ID
%token<ttype> NUMBER NULLT READ NEW THIS
%left<ttype> LPAREN RPAREN LBRACKET RBRACKET
%left<ttype> PLUS MINUS NOT OR
%left<ttype> TIMES DIV MOD AND
%left<ttype> EQ NE GE LE GT LT
%token<ttype> INT

// To be made use of in the future
%token ER_WD ER_CH TAB WHILE RETURN CLASS PRINT VOID ELSE IF COMMA ASSIGN KEY_INT RBRACE LBRACE

%expect 0

%%

program:
    classDeclarations { 
        tree = new NProgram(static_cast<NClassDecl*>($1));
        $$ = tree;
    }
;

classDeclarations:
    CLASS ID classBody {
        NKeyword *cls = new NKeyword($1);
        $$ = new NClassDecl(cls, $2, $3);
    }
;

classBody:
    varDeclarationList constructorDeclarationList methodDeclarationList {
        $$ = new NClassBody($1, $2, $3);
    }
;

varDeclarationList:
    type ID SEMI varDeclarationList {
        // TODO
    }
|   /* epsilon */ {
        $$ = new NEpsilon();
    }
;

type:
    simpleType {
        $$ = new NType($1)
    }
|   type LBRACKET RBRACKET {
        // Todo remove left recursion
    }
;

simpleType:
    INT {
        NKeyword *intKword = new NKeyword("int");
        $$ = new NSimpleType(static_cast<NKeyword *>(intKword));
    }
|   ID {
        $$ = new NSimpleType($1);
    }
;

constructorDeclarationList:
    ID LPAREN parameterList RPAREN block {
        // TODO
    }
|   /* epsilon */ {
        $$ = new NEpsilon();
    }
;

methodDeclarationList:
    resultType ID LPAREN parameterList RPAREN block {
        // TODO
    }
|   /* epsilon */ {
        $$ = new NEpsilon();
    }
;

resultType:
    type {
        $$ = new NResultType(static_cast<NType *>($1));
    }
|   VOID {
        $$ = new NKeyword("void");
    }
;

parameterList:
    parameter parameterListStar {
        // TODO properly build this list
        $$ = new LParams();
    }
|   /* epsilon */ {
        $$ = new NEpsilon();
    }
;

parameterListStar:
    parameter parameterListStar {
        // TODO properly build this list
        // similar to the production for parameterList
    }
|   /* epsilon */ {
        $$ = new NEpsilon();
    }
;

parameter:
    type ID {
        $$ = new NParam(static_cast<NType *>($1), static_cast<NId *>($2));
    }
;

block:
    LBRACE localVarDeclarationStar statementStar RBRACKET {
        // TODO
    }
;

localVarDeclarationStar:
    localVarDeclaration localVarDeclarationStar {

    }
|   /* epsilon */ {
        $$ = new NEpsilon();
    }
;

localVarDeclaration:
    type ID SEMI {
        $$ = new NVarDecl(static_cast<NType *>($1), static_cast<NId *>($2));
    }
;

statementStar:
    statement statementStar {
        // TODO
    }
|   /* epsilon */ {
        $$ = new NEpsilon();
    }
;

statement:
    SEMI {}
|   name EQ expression SEMI {
        // TODO
    }
|   name LPAREN argList RPAREN SEMI {
        // TODO
    }
|   PRINT LPAREN argList RPAREN SEMI {
        // TODO
    }
|   conditionalStatement {
        // TODO
    }
|   WHILE LPAREN expression RPAREN statement {
        // TODO
    }
|   RETURN optionalExpression {
        // TODO
    }
|   block {
        // TODO
    }
;

name:
    THIS {
        // TODO
    }
|   ID {
        // TODO
    }
|   name DOT ID {
        // TODO
    }
|   name LBRACKET expression RBRACKET {
        // TODO
    }
;

argList:
    expression argListStar {
        // TODO
    }
|   /* epsilon */ {
        $$ = new NEpsilon();
    }
;

argListStar:
    expression argListStar {
        // TODO
    }
|   /* epsilon */ {
        $$ = new NEpsilon();
    }
;

conditionalStatement:
    IF LPAREN expression RPAREN statement maybeElse {
        // TODO
    }
;

maybeElse:
    ELSE statement {
        // TODO
    }
|   /* epsilon */ {
        $$ = new NEpsilon();
    }
;

optionalExpression:
    expression {
        // TODO
    }
|   /* epsilon */ {
        $$ = new NEpsilon();
    }
;

expression:

;

newExpression:
;

unaryOp:
;

relationOp:
;

sumOp:
;

productOp:
;


%%
